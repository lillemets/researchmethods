<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Hypothesis testing Comparing categorical data</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jüri Lillemets" />
    <meta name="date" content="2021-05-05" />
    <script src="03_hypothesis_files/header-attrs-2.7/header-attrs.js"></script>
    <link rel="stylesheet" href="minimal.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Hypothesis testing<br>Comparing categorical data
## Research methods
### Jüri Lillemets
### 2021-05-05

---




class: center middle clean

# Is there a difference in frequencies?

---

class: center middle inverse

# Population and sample

---

## But I only have a sample...

When we have data on the entire population we can simply describe it using descriptive statistics. 

But often we only have a part of the population, i.e. a sample.

--

Since we only have data on sample, we can't be sure if same properties hold for population.

Hence, we need to make inferences about the population by estimating population parameters from **random** sample data.

--

We can make inferences with a particular certainty, i.e. confidence interval or error ratio.


???

Sample must be taken from the population *randomly*. For this, every value in the population must have an equal chance of being in sample.

---

## Population mean and standard deviation

Our best estimate of population mean is sample mean, i.e. 

`$$\hat{\mu} = \bar{x}.$$`

--

However, population standard error estimate needs to be corrected for bias as follows:

`$$\hat{\sigma} = \sqrt{\frac{1}{n-1} \sum{^n_{i=1}{(x_i-\bar{x})^2}}}.$$`

???

For small `\(n\)`, SD is biased towards lower values, we need to "inflate" it.

---

## Confidence interval of the mean

We assume that our sample data comes from normally distributed population data.

Then 95% confidence interval (CI) of the mean can be found as follows:

`$$CI_{95} = \hat{x} \pm(1.96\times\frac{\sigma}{\sqrt{N}}).$$`

--

`\(CI_{95}\)` **does not** indicate a 95% probability that true mean lies within the CI!

???

No intuitive interpretation. It means that 95% of samples contain the true mean. It just means that we're pretty sure that population mean is within the CI.

---

### Why 1.96 for 95% CI?

For normally distributed standardized data, we expect 95% of values to lie no further than 1.96 units from the mean.

![](03_hypothesis_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;

???

If distribution was not symmetric we would have different intervals. Data is not standardized, hence the multiplication with SD.

---

class: center middle inverse

# Statistical hypothesis testing

---

## Why statistical hypothesis testing?

Is the color of M&amp;Ms in a bag random? Let's look at 30 bags of M&amp;Ms.

--

![](03_hypothesis_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

???
Silly example but there's an application in agri-food business.

---

If these were the observed frequencies, we could say that frequencies are different.

![](03_hypothesis_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

However, here we can't be so sure.

![](03_hypothesis_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

## What about sample and population?

Does our sample of observed values come from the population represented by expected values? 

![](03_hypothesis_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---

class: center middle inverse

#  Comparing categorical data

---

## Goodness of fit `\(\chi^2\)`-test

We wish to know if the frequencies of categories are different from expected values.

Observed frequencies in bag 19:


|   | Red| Green| Blue| Orange| Yellow| Brown|
|:--|---:|-----:|----:|------:|------:|-----:|
|19 |  10|    12|   11|      6|     11|     7|

Expected frequencies if we expect an equal number of all colors:


| Red| Green| Blue| Orange| Yellow| Brown|
|---:|-----:|----:|------:|------:|-----:|
| 9.5|   9.5|  9.5|    9.5|    9.5|   9.5|

???
Also empirical and theoretical. We can also choose different expected values.

---

## Test statistic

The value of a test statistic indicates how extreme the differences are.

The test statistic for goodness of fit `\(\chi^2\)`-test is calculated as

`$$\chi^2 = \sum{^k_{i=1}{\frac{(O_i-E_i)^2}{E_i}}}$$`

--




```r
obs
exp
sum((obs - exp)^2 / exp)
```

```
## [1] 10 12 11  6 11  7
## [1] 9.5 9.5 9.5 9.5 9.5 9.5
## [1] 3.105263
```

???
The higher the differences, the higher the test statistic.

---

## P-value

This is the probability that a sample value (e.g. the difference) is equal to or more extreme than true value if null hypothesis is true.

Thus, it's the rate of committing a type I error, i.e. the significance level `\(\alpha\)`. 

For testing we set a threshold for p-value **beforehand**, conventionally 0.05.

Conventionally, `\(\alpha = 0.05\)`. So we accept the rate of committing a type I error of 5%.

???
Why set p-value beforehand. We need to make some concessions, hence need to accept error.

---

P-value for `\(\chi^2\)` = 3.1052632 on 5 DoF is 0.6837612. Why?

![](03_hypothesis_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---

## Hypotheses

We posit two hypotheses:

`\(H_0\)`: There **is no** statistically significant difference.&lt;br&gt;
`\(H_1\)`: There **is** a statistically significant difference.

We only test null hypothesis, `\(H_0\)`. When we can not confirm `\(H_0\)`, we accept the alternative hypothesis, `\(H_1\)`.

Suppose that `\(\alpha = 0.05\)`. If p-value is `\(\ge 0.05\)`, we accept `\(H_0\)`. If p-value is `\(\lt 0.05\)`, we reject `\(H_{0}\)` and accept `\(H_1\)`.

P-value is **not** the probability of `\(H_0\)` being false or `\(H_1\)` being true!

---

Hypotheses for for goodness of fit `\(\chi^2\)`-test:

`\(H_0\)`: Frequencies of categories are as expected.&lt;br&gt;
`\(H_1\)`: Frequencies of categories are different from what is expected.

---

class: center middle

Our p-value is 0.6837612 and `\(\alpha = 0.05\)`.

## Are the frequencies of M&amp;M colors in bag 19 random?

???

NHST. Theoretically, the value of p-value itself is not important.

---

##  `\(\chi^2\)`-test of independence

This is done as in previous example, except that we now sum both row and column differences:

`$$\chi^2 = \sum{^r_{i=1}\sum{^c_{j=1}}{\frac{(O_{ij}-E_{ij})^2}{E_{ij}}}}.$$`

Hypotheses for `\(\chi^2\)`-test of independence:

`\(H_0\)`: Variables are independent.&lt;br&gt;
`\(H_1\)`: Variables are associated.

---

class: inverse
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
